import { ApifyClient } from 'apify-client';

// Apify 클라이언트 초기화
const apifyClient = new ApifyClient({
  token: process.env.APIFY_API_TOKEN,
});

/**
 * YouTube 채널 분석 유틸리티 (Apify 기반)
 */

// 📊 YouTube 영상 정보 타입 (Apify 실제 구조에 맞춘 타입)
export interface YouTubeVideo {
  id: string;
  title: string;
  description: string;
  published_at: string;
  view_count: number;
  duration_seconds: number;
  url: string;
  transcript?: string;
  channel_id: string;
  channel_title: string;
  
  // Apify 원본 필드들 (AI 분석용)
  channelName?: string;
  numberOfSubscribers?: number;
  channelTotalVideos?: number;
  channelDescription?: string;
  viewCount?: number;
  likes?: number;
  commentsCount?: number;
  date?: string;
  text?: string;
  subtitles?: Array<{
    language?: string;
    plaintext?: string;
    type?: string;
  }>;
}

// 📈 채널 분석 결과 타입
export interface ChannelAnalysisResult {
  channel_info: {
  id: string;
  title: string;
    url: string;
  };
  videos: YouTubeVideo[];
  analysis_summary: {
    total_videos: number;
    videos_with_subtitles: number;
    avg_duration_minutes: number;
    total_views: number;
    latest_video_date: string;
  };
}

/**
 * 🔍 YouTube URL 검증
 */
export function extractChannelInfo(url: string): { type: string; url: string } | null {
  try {
    if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
      return null;
    }

    // 다양한 URL 형태 지원
    if (url.includes('/watch?v=') || url.includes('youtu.be/')) {
      return { type: 'video', url };
    }
    
    if (url.includes('/channel/') || url.includes('/c/') || url.includes('/@')) {
      return { type: 'channel', url };
    }

    return { type: 'unknown', url };
  } catch {
    return null;
  }
}

/**
 * 🎯 YouTube 채널 분석 (자막 포함)
 */
export async function analyzeYouTubeChannel(
  channelUrl: string, 
  maxVideos: number = 5
): Promise<ChannelAnalysisResult> {
  try {
    // URL 검증
    const channelInfo = extractChannelInfo(channelUrl);
    if (!channelInfo) {
      throw new Error('올바른 YouTube URL을 입력해주세요.');
    }

    // API 토큰 확인
    if (!process.env.APIFY_API_TOKEN || process.env.APIFY_API_TOKEN === 'your_apify_api_token_here') {
      throw new Error('Apify API 토큰이 설정되지 않았습니다.');
    }

    console.log(`🔍 채널 분석 시작: ${maxVideos}개 영상 (자막 포함)`);

    // 🎬 Apify YouTube Scraper 실행
    const input = {
      downloadSubtitles: true,
      hasCC: false,
      hasLocation: false,
      hasSubtitles: false,
      is360: false,
      is3D: false,
      is4K: false,
      isBought: false,
      isHD: false,
      isHDR: false,
      isLive: false,
      isVR180: false,
      maxResultStreams: 0,
      maxResults: maxVideos,
      maxResultsShorts: 0,
      preferAutoGeneratedSubtitles: true,
      saveSubsToKVS: false,
      startUrls: [
        {
          url: channelUrl,
          method: "GET"
        }
      ],
      subtitlesFormat: "plaintext",
      subtitlesLanguage: "any",
      videoType: "video"
    };

    const run = await apifyClient.actor("h7sDV53CddomktSi5").call(input);

    // 결과 데이터 가져오기
    const { items } = await apifyClient.dataset(run.defaultDatasetId).listItems();  
    console.log(items);
    
    if (!items || items.length === 0) {
      throw new Error('채널에서 영상을 찾을 수 없습니다.');
    }

    console.log(`📊 ${items.length}개 영상 데이터 수집됨`);

    // 🔧 데이터 정리 및 변환
    const videos: YouTubeVideo[] = items.map((item: Record<string, unknown>) => {
      // 📝 자막 처리
      let transcript = undefined;
      
      if (item.subtitles && Array.isArray(item.subtitles) && item.subtitles.length > 0) {
        console.log(`🌍 ${item.title}: ${item.subtitles.length}개 언어 자막 발견`);
        
        // 언어 우선순위: 한국어 → 영어 → 자동생성 → 기타
        const priorityLanguages = ['ko', 'kr', 'korean', 'en', 'english', 'auto'];
        let selectedSubtitle = null;
        
        // 우선순위에 따라 자막 선택
        for (const lang of priorityLanguages) {
          selectedSubtitle = item.subtitles.find((sub: Record<string, unknown>) => {
            const langCode = String(sub.language || sub.languageCode || '').toLowerCase();
            const subType = String(sub.type || '').toLowerCase();
            
            if (lang === 'ko' && langCode === 'ko') return true;
            if (lang === 'kr' && (langCode === 'kr' || langCode.includes('kr'))) return true;
            if (lang === 'korean' && langCode.includes('korean')) return true;
            if (lang === 'en' && langCode === 'en') return true;
            if (lang === 'english' && langCode.includes('english')) return true;
            if (lang === 'auto' && subType.includes('auto')) return true;
            
            return false;
          });
          if (selectedSubtitle) {
            console.log(`✅ 선택된 언어: ${selectedSubtitle.language || selectedSubtitle.languageCode || 'unknown'}`);
            break;
          }
        }
        
        // 우선순위 언어가 없으면 첫 번째 자막 사용
        if (!selectedSubtitle && item.subtitles[0]) {
          selectedSubtitle = item.subtitles[0];
          console.log(`📝 기본 자막 사용: ${selectedSubtitle.language || 'unknown'}`);
        }
        
        // 자막 텍스트 추출 및 정리
        if (selectedSubtitle) {
          transcript = selectedSubtitle.plaintext || selectedSubtitle.text || selectedSubtitle.content;
          
          if (transcript && transcript.length > 50) {
            transcript = transcript
            .replace(/\d+\n\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}\n/g, '')
            .replace(/\n+/g, ' ')
            .replace(/\s+/g, ' ')
              .replace(/[^\w\s가-힣.,!?]/g, ' ')
            .trim();
            
            // 너무 짧은 자막은 제외
            if (transcript.length < 100) {
              transcript = undefined;
            }
          } else {
            transcript = undefined;
          }
        }
      }

      return {
        // 기본 필드들 (기존 호환성 유지)
        id: String(item.id || item.videoId || ''),
        title: String(item.title || '제목 없음'),
        description: String(item.text || item.description || ''),
        published_at: String(item.date || item.publishedAt || ''),
        view_count: Number(item.viewCount) || 0,
        duration_seconds: Number(item.lengthSeconds) || 0,
        url: String(item.url || `https://youtube.com/watch?v=${item.id || item.videoId}`),
        transcript,
        channel_id: String(item.channelId || ''),
        channel_title: String(item.channelName || item.channelTitle || ''),
        
        // Apify 원본 필드들 (AI 분석용)
        channelName: item.channelName ? String(item.channelName) : undefined,
        numberOfSubscribers: item.numberOfSubscribers ? Number(item.numberOfSubscribers) : undefined,
        channelTotalVideos: item.channelTotalVideos ? Number(item.channelTotalVideos) : undefined,
        channelDescription: item.channelDescription ? String(item.channelDescription) : undefined,
        viewCount: item.viewCount ? Number(item.viewCount) : undefined,
        likes: item.likes ? Number(item.likes) : undefined,
        commentsCount: item.commentsCount ? Number(item.commentsCount) : undefined,
        date: item.date ? String(item.date) : undefined,
        text: item.text ? String(item.text) : undefined,
        subtitles: Array.isArray(item.subtitles) ? item.subtitles as Array<{
          language?: string;
          plaintext?: string;
          type?: string;
        }> : undefined
      };
    });

    // 📊 분석 요약 생성
    const videosWithSubtitles = videos.filter(v => v.transcript && v.transcript.length > 100);
    const totalViews = videos.reduce((sum, v) => sum + v.view_count, 0);
    const avgDuration = videos.length > 0 
      ? Math.round(videos.reduce((sum, v) => sum + v.duration_seconds, 0) / videos.length / 60)
      : 0;

    const result: ChannelAnalysisResult = {
      channel_info: {
        id: videos[0]?.channel_id || '',
        title: videos[0]?.channel_title || '채널명 미상',
        url: channelUrl
      },
      videos,
      analysis_summary: {
        total_videos: videos.length,
        videos_with_subtitles: videosWithSubtitles.length,
        avg_duration_minutes: avgDuration,
        total_views: totalViews,
        latest_video_date: videos[0]?.published_at || ''
      }
    };

    console.log(`✅ 분석 완료: ${videos.length}개 영상, ${videosWithSubtitles.length}개 자막`);
    
    return result;

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류';
    console.error('❌ 채널 분석 실패:', errorMessage);
    throw new Error(`채널 분석 실패: ${errorMessage}`);
  }
}

/**
 * 🔧 Apify 서비스 사용 가능 여부 확인
 */
export function isApifyAvailable(): boolean {
  const token = process.env.APIFY_API_TOKEN;
  return !!(token && token !== 'your_apify_api_token_here');
}

// 🎯 간단한 유틸리티 함수들
export const utils = {
  // 영상 길이를 "MM:SS" 형태로 변환
  formatDuration: (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  },

  // 조회수를 간단한 형태로 변환 (1.2M, 34K 등)
  formatViewCount: (views: number): string => {
    if (views >= 1000000) return `${(views / 1000000).toFixed(1)}M`;
    if (views >= 1000) return `${(views / 1000).toFixed(1)}K`;
    return views.toString();
  },

  // 날짜를 상대적 시간으로 변환
  formatRelativeDate: (dateString: string): string => {
    try {
      const date = new Date(dateString);
      const now = new Date();
      const diffDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) return '오늘';
      if (diffDays === 1) return '어제';
      if (diffDays < 7) return `${diffDays}일 전`;
      if (diffDays < 30) return `${Math.floor(diffDays / 7)}주 전`;
      if (diffDays < 365) return `${Math.floor(diffDays / 30)}개월 전`;
      return `${Math.floor(diffDays / 365)}년 전`;
    } catch {
      return dateString;
    }
  },

  // 📝 자막 텍스트 요약 (처음 N자만)
  summarizeTranscript: (transcript: string, maxLength: number = 200): string => {
    if (!transcript) return '';
    if (transcript.length <= maxLength) return transcript;
    
    // 문장 단위로 자르기
    const sentences = transcript.split(/[.!?]+/).filter(s => s.trim().length > 0);
    let summary = '';
    
    for (const sentence of sentences) {
      if ((summary + sentence).length > maxLength) break;
      summary += sentence.trim() + '. ';
    }
    
    return summary.trim() + '...';
  }
}; 